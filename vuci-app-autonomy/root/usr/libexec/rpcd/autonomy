#!/usr/bin/lua
-- autonomy RPC daemon plugin for VuCI
-- Provides backend API for the autonomy web interface

local rpcd = require "rpcd"
local ubus = require "ubus"
local json = require "luci.jsonc"
local util = require "luci.util"

local M = {}

-- Initialize ubus connection
local ubus_conn = ubus.connect()
if not ubus_conn then
    error("Failed to connect to ubus")
end

-- Helper function to call autonomy service
local function call_autonomy(method, args)
    if not ubus_conn then
        return { error = "ubus connection not available" }
    end
    
    local result = ubus_conn:call("autonomy", method, args or {})
    if not result then
        return { error = "autonomy service not available" }
    end
    
    return result
end

-- Get system status
function M.status()
    local result = call_autonomy("status")
    if result.error then
        return result
    end
    
    -- Add additional system information
    local sysinfo = {
        uptime = util.exec("cat /proc/uptime | cut -d' ' -f1"),
        loadavg = util.exec("cat /proc/loadavg"),
        memory = util.exec("cat /proc/meminfo | grep -E '^(MemTotal|MemAvailable|MemFree)'"),
        disk = util.exec("df -h / | tail -1")
    }
    
    result.system = sysinfo
    return result
end

-- Get configuration
function M.config()
    return call_autonomy("config")
end

-- Get interfaces
function M.interfaces()
    return call_autonomy("interfaces")
end

-- Get telemetry
function M.telemetry()
    return call_autonomy("telemetry")
end

-- Get health information
function M.health()
    return call_autonomy("health")
end

-- Reload configuration
function M.reload()
    return call_autonomy("reload")
end

-- Get service status
function M.service_status()
    local status = {
        running = false,
        pid = nil,
        uptime = nil,
        memory = nil
    }
    
    -- Check if service is running
    local pid = util.exec("cat /var/run/autonomyd.pid 2>/dev/null")
    if pid and pid:match("^%d+$") then
        status.running = true
        status.pid = tonumber(pid)
        
        -- Get process info
        local ps_output = util.exec("ps -o pid,ppid,etime,pcpu,pmem,comm -p " .. pid)
        if ps_output then
            for line in ps_output:gmatch("[^\r\n]+") do
                if line:match("^%s*" .. pid) then
                    local parts = {}
                    for part in line:gmatch("%S+") do
                        table.insert(parts, part)
                    end
                    if #parts >= 5 then
                        status.uptime = parts[3]
                        status.cpu = parts[4]
                        status.memory = parts[5]
                    end
                    break
                end
            end
        end
    end
    
    return status
end

-- Get logs
function M.logs(lines)
    lines = lines or 50
    local log_file = "/var/log/autonomyd.log"
    
    if not util.file_exists(log_file) then
        return { error = "Log file not found" }
    end
    
    local cmd = string.format("tail -n %d %s", lines, log_file)
    local output = util.exec(cmd)
    
    return { logs = output or "" }
end

-- Get system resources
function M.resources()
    local resources = {}
    
    -- CPU usage
    local cpu_info = util.exec("top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1")
    resources.cpu = tonumber(cpu_info) or 0
    
    -- Memory usage
    local mem_info = util.exec("free | grep Mem | awk '{printf \"%.1f\", $3/$2 * 100.0}'")
    resources.memory = tonumber(mem_info) or 0
    
    -- Disk usage
    local disk_info = util.exec("df / | tail -1 | awk '{print $5}' | cut -d'%' -f1")
    resources.disk = tonumber(disk_info) or 0
    
    -- Network interfaces
    resources.interfaces = {}
    local ifaces = util.exec("ip link show | grep '^[0-9]' | awk '{print $2}' | cut -d':' -f1")
    if ifaces then
        for iface in ifaces:gmatch("[^\r\n]+") do
            local rx_bytes = util.exec(string.format("cat /sys/class/net/%s/statistics/rx_bytes 2>/dev/null", iface)) or "0"
            local tx_bytes = util.exec(string.format("cat /sys/class/net/%s/statistics/tx_bytes 2>/dev/null", iface)) or "0"
            
            table.insert(resources.interfaces, {
                name = iface,
                rx_bytes = tonumber(rx_bytes) or 0,
                tx_bytes = tonumber(tx_bytes) or 0
            })
        end
    end
    
    return resources
end

-- Get historical data for monitoring
function M.historical_data()
    local data = {
        cpu = {},
        memory = {},
        disk = {},
        network = {},
        interfaces = {}
    }
    
    -- Read historical data from RRD files or log files
    local rrd_dir = "/var/lib/autonomy/rrd"
    local log_file = "/var/log/autonomy-metrics.log"
    
    -- If RRD files exist, use them
    if util.file_exists(rrd_dir) then
        -- Read CPU data
        local cpu_rrd = rrd_dir .. "/cpu.rrd"
        if util.file_exists(cpu_rrd) then
            local cpu_data = util.exec("rrdtool fetch " .. cpu_rrd .. " AVERAGE -s -1h")
            if cpu_data then
                for line in cpu_data:gmatch("[^\r\n]+") do
                    local timestamp, value = line:match("^(%d+): ([%d%.]+)")
                    if timestamp and value then
                        table.insert(data.cpu, {
                            timestamp = tonumber(timestamp),
                            value = tonumber(value)
                        })
                    end
                end
            end
        end
        
        -- Read memory data
        local mem_rrd = rrd_dir .. "/memory.rrd"
        if util.file_exists(mem_rrd) then
            local mem_data = util.exec("rrdtool fetch " .. mem_rrd .. " AVERAGE -s -1h")
            if mem_data then
                for line in mem_data:gmatch("[^\r\n]+") do
                    local timestamp, value = line:match("^(%d+): ([%d%.]+)")
                    if timestamp and value then
                        table.insert(data.memory, {
                            timestamp = tonumber(timestamp),
                            value = tonumber(value)
                        })
                    end
                end
            end
        end
    else
        -- Fallback to log file parsing
        if util.file_exists(log_file) then
            local cmd = string.format("tail -n 100 %s | grep -E '^(CPU|MEM|DISK)'", log_file)
            local output = util.exec(cmd)
            
            if output then
                for line in output:gmatch("[^\r\n]+") do
                    local metric, timestamp, value = line:match("^(%w+) (%d+) ([%d%.]+)")
                    if metric and timestamp and value then
                        local entry = {
                            timestamp = tonumber(timestamp),
                            value = tonumber(value)
                        }
                        
                        if metric == "CPU" then
                            table.insert(data.cpu, entry)
                        elseif metric == "MEM" then
                            table.insert(data.memory, entry)
                        elseif metric == "DISK" then
                            table.insert(data.disk, entry)
                        end
                    end
                end
            end
        end
    end
    
    -- Get interface statistics over time
    local interfaces = util.exec("ip link show | grep '^[0-9]' | awk '{print $2}' | cut -d':' -f1")
    if interfaces then
        for iface in interfaces:gmatch("[^\r\n]+") do
            data.interfaces[iface] = {
                rx_bytes = {},
                tx_bytes = {},
                errors = {},
                drops = {}
            }
            
            -- Read interface statistics from sysfs
            local rx_bytes = util.exec(string.format("cat /sys/class/net/%s/statistics/rx_bytes 2>/dev/null", iface)) or "0"
            local tx_bytes = util.exec(string.format("cat /sys/class/net/%s/statistics/tx_bytes 2>/dev/null", iface)) or "0"
            local rx_errors = util.exec(string.format("cat /sys/class/net/%s/statistics/rx_errors 2>/dev/null", iface)) or "0"
            local tx_errors = util.exec(string.format("cat /sys/class/net/%s/statistics/tx_errors 2>/dev/null", iface)) or "0"
            local rx_dropped = util.exec(string.format("cat /sys/class/net/%s/statistics/rx_dropped 2>/dev/null", iface)) or "0"
            local tx_dropped = util.exec(string.format("cat /sys/class/net/%s/statistics/tx_dropped 2>/dev/null", iface)) or "0"
            
            local now = os.time()
            table.insert(data.interfaces[iface].rx_bytes, { timestamp = now, value = tonumber(rx_bytes) or 0 })
            table.insert(data.interfaces[iface].tx_bytes, { timestamp = now, value = tonumber(tx_bytes) or 0 })
            table.insert(data.interfaces[iface].errors, { timestamp = now, value = (tonumber(rx_errors) or 0) + (tonumber(tx_errors) or 0) })
            table.insert(data.interfaces[iface].drops, { timestamp = now, value = (tonumber(rx_dropped) or 0) + (tonumber(tx_dropped) or 0) })
        end
    end
    
    return data
end

-- Get alerts and notifications
function M.alerts()
    local alerts = {
        active = {},
        history = {},
        settings = {}
    }
    
    -- Read alert settings from UCI
    local uci = require "uci"
    local cursor = uci.cursor()
    
    cursor:foreach("autonomy", "alerts", function(section)
        if section[".name"] == "settings" then
            alerts.settings = section
        end
    end)
    
    -- Read active alerts from log
    local alert_log = "/var/log/autonomy-alerts.log"
    if util.file_exists(alert_log) then
        local cmd = string.format("tail -n 50 %s | grep -E '^(ALERT|WARNING|CRITICAL)'", alert_log)
        local output = util.exec(cmd)
        
        if output then
            for line in output:gmatch("[^\r\n]+") do
                local level, timestamp, message = line:match("^(%w+) (%d+) (.+)")
                if level and timestamp and message then
                    local alert = {
                        level = level,
                        timestamp = tonumber(timestamp),
                        message = message,
                        time_ago = os.time() - tonumber(timestamp)
                    }
                    
                    if alert.time_ago < 3600 then -- Last hour
                        table.insert(alerts.active, alert)
                    else
                        table.insert(alerts.history, alert)
                    end
                end
            end
        end
    end
    
    -- Check for system-level alerts
    local resources = M.resources()
    if resources.cpu and resources.cpu > 90 then
        table.insert(alerts.active, {
            level = "CRITICAL",
            timestamp = os.time(),
            message = "CPU usage is critically high: " .. resources.cpu .. "%",
            time_ago = 0
        })
    elseif resources.cpu and resources.cpu > 80 then
        table.insert(alerts.active, {
            level = "WARNING",
            timestamp = os.time(),
            message = "CPU usage is high: " .. resources.cpu .. "%",
            time_ago = 0
        })
    end
    
    if resources.memory and resources.memory > 90 then
        table.insert(alerts.active, {
            level = "CRITICAL",
            timestamp = os.time(),
            message = "Memory usage is critically high: " .. resources.memory .. "%",
            time_ago = 0
        })
    elseif resources.memory and resources.memory > 80 then
        table.insert(alerts.active, {
            level = "WARNING",
            timestamp = os.time(),
            message = "Memory usage is high: " .. resources.memory .. "%",
            time_ago = 0
        })
    end
    
    if resources.disk and resources.disk > 95 then
        table.insert(alerts.active, {
            level = "CRITICAL",
            timestamp = os.time(),
            message = "Disk usage is critically high: " .. resources.disk .. "%",
            time_ago = 0
        })
    elseif resources.disk and resources.disk > 90 then
        table.insert(alerts.active, {
            level = "WARNING",
            timestamp = os.time(),
            message = "Disk usage is high: " .. resources.disk .. "%",
            time_ago = 0
        })
    end
    
    return alerts
end

-- Get UCI configuration
function M.get_uci_config()
    local config = {}
    
    -- Read autonomy config
    local uci = require "uci"
    local cursor = uci.cursor()
    
    cursor:foreach("autonomy", "autonomy", function(section)
        if section[".name"] == "main" then
            config.main = section
        end
    end)
    
    cursor:foreach("autonomy", "thresholds", function(section)
        config.thresholds = config.thresholds or {}
        config.thresholds[section[".name"]] = section
    end)
    
    cursor:foreach("autonomy", "interface", function(section)
        config.interfaces = config.interfaces or {}
        config.interfaces[section[".name"]] = section
    end)
    
    cursor:foreach("autonomy", "starlink", function(section)
        if section[".name"] == "api" then
            config.starlink_api = section
        end
    end)
    
    cursor:foreach("autonomy", "monitoring", function(section)
        if section[".name"] == "mqtt" then
            config.mqtt = section
        end
    end)
    
    cursor:foreach("autonomy", "notifications", function(section)
        if section[".name"] == "pushover" then
            config.pushover = section
        end
    end)
    
    return config
end

-- Set UCI configuration
function M.set_uci_config(config)
    local uci = require "uci"
    local cursor = uci.cursor()
    
    -- Update main section
    if config.main then
        for key, value in pairs(config.main) do
            if key:sub(1, 1) ~= "." then
                cursor:set("autonomy", "main", key, value)
            end
        end
    end
    
    -- Update thresholds
    if config.thresholds then
        for section_name, section_data in pairs(config.thresholds) do
            for key, value in pairs(section_data) do
                if key:sub(1, 1) ~= "." then
                    cursor:set("autonomy", section_name, key, value)
                end
            end
        end
    end
    
    -- Update interfaces
    if config.interfaces then
        for section_name, section_data in pairs(config.interfaces) do
            for key, value in pairs(section_data) do
                if key:sub(1, 1) ~= "." then
                    cursor:set("autonomy", section_name, key, value)
                end
            end
        end
    end
    
    -- Commit changes
    cursor:commit("autonomy")
    
    return { success = true }
end

-- Register RPC methods
local methods = {
    status = M.status,
    config = M.config,
    interfaces = M.interfaces,
    telemetry = M.telemetry,
    health = M.health,
    reload = M.reload,
    service_status = M.service_status,
    logs = M.logs,
    resources = M.resources,
    historical_data = M.historical_data,
    alerts = M.alerts,
    get_uci_config = M.get_uci_config,
    set_uci_config = M.set_uci_config
}

-- Start RPC daemon
rpcd.run(methods)

