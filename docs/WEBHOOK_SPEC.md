# autonomy Watchdog Webhook API Specification

## Overview

The autonomy Watchdog system sends HTTP POST requests to a webhook endpoint when health issues are detected. The webhook server should validate the request, process the alert, and optionally create GitHub issues for tracking.

## Endpoint

**Method**: `POST`  
**Content-Type**: `application/json`  
**URL**: Configurable via `WEBHOOK_URL` in `/etc/autonomy/watch.conf`

## Authentication

### HMAC-SHA256 Signature

All webhook requests include an HMAC signature in the `X-Starwatch-Signature` header:

```
X-Starwatch-Signature: sha256=<hex_signature>
```

**Signature Generation**:
```bash
# On the router (starwatch script)
sig=$(printf '%s' "$payload" | openssl dgst -sha256 -hmac "${WATCH_SECRET}" -binary | xxd -p -c 256)
```

**Signature Validation** (server-side):
```python
import hmac
import hashlib

def validate_signature(payload, signature, secret):
    expected = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(signature, expected)
```

## Request Payload

### Schema

```json
{
  "device_id": "string",           // Device identifier (hostname or custom)
  "fw": "string",                  // Firmware version
  "severity": "string",            // "critical" | "warn" | "info"
  "scenario": "string",            // Issue scenario identifier
  "overlay_pct": "number",         // Overlay filesystem usage percentage
  "mem_avail_mb": "number",        // Available memory in MB
  "load1": "number",               // 1-minute load average
  "ubus_ok": "boolean",            // ubus/rpcd health status
  "actions": ["string"],           // Actions taken by watchdog
  "note": "string",                // Human-readable description
  "ts": "number"                   // Unix timestamp
}
```

### Field Descriptions

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `device_id` | string | Unique device identifier | `"rutx50-van-01"` |
| `fw` | string | Router firmware version | `"RUTX_R_00.07.17"` |
| `severity` | string | Alert severity level | `"critical"` |
| `scenario` | string | Issue scenario type | `"crash_loop"` |
| `overlay_pct` | number | Overlay filesystem usage | `96` |
| `mem_avail_mb` | number | Available memory in MB | `12` |
| `load1` | number | 1-minute load average | `5.3` |
| `ubus_ok` | boolean | ubus/rpcd health | `false` |
| `actions` | array | Actions taken | `["restart", "hold_down"]` |
| `note` | string | Human description | `"Daemon in crash loop"` |
| `ts` | number | Unix timestamp | `1737388800` |

### Severity Levels

- **`critical`**: Immediate attention required (crash loops, system reboots)
- **`warn`**: Monitor closely (high resource usage, service restarts)
- **`info`**: Informational (status updates, recovery actions)

### Scenario Types

| Scenario | Description | Severity | Actions |
|----------|-------------|----------|---------|
| `daemon_down` | Daemon process not running | warn | `["restart"]` |
| `daemon_hung` | Daemon not responding | warn | `["restart"]` |
| `crash_loop` | Repeated daemon crashes | critical | `["hold_down", "restart"]` |
| `system_degraded` | High resource usage | warn | `["log_prune"]` |
| `slow` | System performance issues | warn | `[]` |
| `post_reboot` | System rebooted | critical | `["reboot"]` |

## Response Handling

### Success Response

**Status**: `200 OK` or `202 Accepted`  
**Body**: Optional JSON response

```json
{
  "status": "accepted",
  "issue_id": "12345",
  "message": "GitHub issue created successfully"
}
```

### Error Response

**Status**: `4xx` or `5xx`  
**Body**: Error details

```json
{
  "error": "invalid_signature",
  "message": "HMAC signature validation failed"
}
```

## GitHub Issue Integration

### Issue Creation

When a webhook is received, the server should:

1. **Validate HMAC signature**
2. **Deduplicate** by device_id + scenario + time bucket (15-minute windows)
3. **Create GitHub issue** with appropriate labels
4. **Attach diagnostic bundle** (if available)

### Issue Template

```markdown
## autonomy Watchdog Alert

**Device**: {{device_id}}  
**Firmware**: {{fw}}  
**Severity**: {{severity}}  
**Scenario**: {{scenario}}  
**Timestamp**: {{timestamp}}  

### System Status
- **Overlay Usage**: {{overlay_pct}}%
- **Available Memory**: {{mem_avail_mb}}MB
- **Load Average**: {{load1}}
- **ubus Health**: {{ubus_ok}}

### Actions Taken
{{#actions}}
- {{.}}
{{/actions}}

### Description
{{note}}

### Diagnostic Bundle
[Download diagnostic bundle]({{bundle_url}})

---
*Auto-generated by autonomy Watchdog*
```

### Labels

| Label | Description | Auto-assigned |
|-------|-------------|---------------|
| `device:{{device_id}}` | Device identifier | Yes |
| `severity:{{severity}}` | Alert severity | Yes |
| `scenario:{{scenario}}` | Issue scenario | Yes |
| `autonomy-watchdog` | Watchdog alerts | Yes |
| `auto-generated` | Automated issue | Yes |
| `needs-attention` | Requires manual review | Yes (critical) |
| `investigating` | Under investigation | Manual |
| `resolved` | Issue resolved | Manual |

## Queue and Retry

### Offline Queue

When the webhook server is unavailable, the watchdog:

1. **Queues the payload** in `/tmp/starwatch.queue/`
2. **Retries on next run** (every 6 minutes)
3. **Flushes queue** when connection is restored

### Queue Format

Each queued file contains the full JSON payload:
```
/tmp/starwatch.queue/1737388800.json
```

### Queue Management

- **Automatic cleanup**: Queued files are removed after successful delivery
- **Size limits**: Queue directory is monitored for disk usage
- **Retry limits**: No explicit limit (continues until successful)

## Security Considerations

### HMAC Validation

**Critical**: Always validate the HMAC signature before processing:

```python
def process_webhook(request):
    # Extract signature
    signature = request.headers.get('X-Starwatch-Signature', '')
    if not signature.startswith('sha256='):
        return error_response('invalid_signature_format')
    
    signature = signature[7:]  # Remove 'sha256=' prefix
    
    # Validate signature
    if not validate_signature(request.body, signature, WATCH_SECRET):
        return error_response('invalid_signature')
    
    # Process payload
    return process_payload(request.json)
```

### Rate Limiting

Implement rate limiting to prevent abuse:

- **Per device**: Max 10 requests per minute
- **Per IP**: Max 100 requests per minute
- **Global**: Max 1000 requests per minute

### Input Validation

Validate all fields in the payload:

```python
def validate_payload(data):
    required_fields = ['device_id', 'severity', 'scenario', 'ts']
    for field in required_fields:
        if field not in data:
            raise ValueError(f"Missing required field: {field}")
    
    if data['severity'] not in ['critical', 'warn', 'info']:
        raise ValueError("Invalid severity level")
    
    if data['ts'] < time.time() - 3600:  # 1 hour ago
        raise ValueError("Timestamp too old")
```

## Implementation Examples

### Python Flask Server

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import json
import time

app = Flask(__name__)
WATCH_SECRET = "your_secret_here"

def validate_signature(payload, signature, secret):
    expected = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(signature, expected)

@app.route('/webhook/starwatch', methods=['POST'])
def starwatch_webhook():
    # Validate signature
    signature = request.headers.get('X-Starwatch-Signature', '')
    if not signature.startswith('sha256='):
        return jsonify({'error': 'invalid_signature'}), 400
    
    signature = signature[7:]
    if not validate_signature(request.data.decode(), signature, WATCH_SECRET):
        return jsonify({'error': 'invalid_signature'}), 401
    
    # Process payload
    data = request.json
    issue_id = create_github_issue(data)
    
    return jsonify({
        'status': 'accepted',
        'issue_id': issue_id
    }), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

### Node.js Express Server

```javascript
const express = require('express');
const crypto = require('crypto');
const app = express();

const WATCH_SECRET = 'your_secret_here';

function validateSignature(payload, signature, secret) {
    const expected = crypto
        .createHmac('sha256', secret)
        .update(payload)
        .digest('hex');
    return crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expected)
    );
}

app.post('/webhook/starwatch', express.json(), (req, res) => {
    const signature = req.headers['x-starwatch-signature'];
    if (!signature || !signature.startsWith('sha256=')) {
        return res.status(400).json({ error: 'invalid_signature' });
    }
    
    const sig = signature.substring(7);
    const payload = JSON.stringify(req.body);
    
    if (!validateSignature(payload, sig, WATCH_SECRET)) {
        return res.status(401).json({ error: 'invalid_signature' });
    }
    
    // Process the webhook
    const issueId = createGitHubIssue(req.body);
    
    res.json({
        status: 'accepted',
        issue_id: issueId
    });
});

app.listen(8080, () => {
    console.log('Webhook server running on port 8080');
});
```

## Testing

### Test Payload

```json
{
  "device_id": "test-device",
  "fw": "TEST_FW_1.0.0",
  "severity": "warn",
  "scenario": "daemon_restart",
  "overlay_pct": 85,
  "mem_avail_mb": 64,
  "load1": 1.2,
  "ubus_ok": true,
  "actions": ["restart"],
  "note": "Test webhook payload",
  "ts": 1737388800
}
```

### Test Commands

```bash
# Test webhook locally
curl -X POST http://localhost:8080/webhook/starwatch \
  -H "Content-Type: application/json" \
  -H "X-Starwatch-Signature: sha256=$(echo -n '{"test":"data"}' | openssl dgst -sha256 -hmac "test_secret" -binary | xxd -p -c 256)" \
  -d '{"test":"data"}'

# Test from router
/usr/sbin/starwatch
```

## Monitoring

### Health Checks

Monitor webhook server health:

```bash
# Check webhook endpoint
curl -f http://your.server/webhook/starwatch/health

# Check GitHub API rate limits
curl -H "Authorization: token $GITHUB_TOKEN" \
  https://api.github.com/rate_limit
```

### Metrics

Track webhook performance:

- **Response time**: Average webhook processing time
- **Success rate**: Percentage of successful webhook deliveries
- **Queue size**: Number of queued notifications
- **Error rate**: Percentage of failed webhook attempts

---

**Last Updated**: 2025-01-20  
**Version**: 1.0  
**Maintainer**: autonomy Development Team
